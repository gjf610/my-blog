## 渲染函数

渲染函数是Vue里响应式渲染系统的另外一半。Vue的templates实际上是通过渲染函数渲染出来的。

### 初始渲染
template
-> 编译渲染函数
-> 返回虚拟DOM
-> 生成真实DOM

在Vue上下文中，当我们第一次渲染一个Vue应用时，会将template放到渲染函数进行编译，这回发生在你是用完整的编译模式，也就是你直接使用DOM模板或者直接给Vue实例传递一个模板字符串。但是你如果是使用Vue CLI 来构建项目用到webpack和vue-loader，vue-loader实际上在构建时预编译template，所以当浏览器访问的代码是不包含原始的template，而是提供了编译的纯JavaScript渲染函数代码。这类似于angular上下文中的ALT编译。这样做会节省很多编译时间，而且我们可以在没有编译器的情况下运行。因此在Vue中提供两种构建方式，一种是完整的构建，它包含一个编译器和运行时代码，另一种是只有运行时代码。

在编译成渲染函数后，渲染函数实际上是一个返回虚拟DOM的函数，Vue基于虚拟DOM生成真实DOM
在这个过程之后，我们产生虚拟DOM的过程，本质上是调用渲染函数。因为渲染函数和所有的data属性有依赖关系，在Vue实例中。同时这些data属性是具有响应性的，所有这些data属性会收集为组件渲染函数的依赖。如果这些依赖关系中的任何一个发生变化，将会再次调用渲染函数，在后续更新中，渲染函数会被再次调用，它会返回一个新的虚拟DOM，旧的虚拟DOM和新的虚拟DOM将被比较和区分，最后把最少量的更新应用到真实DOM中
### 后续更新
渲染函数
-> 返回新的虚拟DOM
-> 对比与旧虚拟DOM的差异
-> 将差异应用/更新到真实DOM中


## 虚拟DOM
真实DOM，很多人知道原生DOM API，例如document.createElement，我们可以创建一个真实的div节点表示在我们的文档流中加入一个div，它内部实际上是通过使用C++编写的浏览器引擎实现的，我们实际上并没有接触到这部分，它只是公开了JavaScript中的API以供我们使用。相比之下，Vue中的虚拟DOM会在每个实例this.$createElement返回一个虚拟节点，这个虚拟节点也表示一个div，但它是一个纯JavaScript对象。差异实际是非常大的，如果你在浏览器中打印div属性，你会看到一个真实的div节点会有很多属性，还有他的底层实现实际上很复杂。我们一般把这些称为原生代码的JavaScript接口，双方的调用成本很高，而且他们会比在JavaScript环境执行JavaScript代码更消耗资源，所以很多时候我们会说修改DOM是缓慢的，有的浏览器可能会做优化，但总的来说，对于经常在JavaScript端调用原生端效果不大.

Actual DOM
"[object HTMLDivElement]"
Browser Native Object(expensive)

Virtual DOM
{tag: 'div', data: {attrs: {}, ...}, children: []} 
Plan JavaStript Object (cheap)

就像你看到的代码，虚拟DOM div只是一个对象，它有一个标签，告诉我们它是一个div，还有一个数据对象，包含一些属性。如果他没有任何属性，就不需要数据对象，还有一个children列表，表示他还有很多虚拟节点。现在我们就有了一个通过虚拟节点组成的虚拟DOM树.

假设我们有1000个元素的列表，创建1000个JavaScript对象是非常节省的，也非常快。但是创建1000个真实div节点要昂贵得多？

Virtual DOM
本质上是轻量的JavaScript数据格式在特定时间来表示真实DOM。因为我们会在每次更新是生成虚拟DOM的副本，能这样做是因为虚拟DOM比真实DOM节省，假设我们使用innerHtml更新应用，我们需要丢弃以前真实的DOM节点，然后重新生成所有真实DOM节点，这个成本是比仅生成一个新的虚拟DOM快照更高昂，而且innerHtml也有一些问题。例如它会丢弃所有表单输入元素或者输入状态。但是常见的一个误解是虚拟DOM让这些框架变快，虚拟DOM只是解决原始DOM的局限性的一个方法，它提供了以声明方式构成你想要的DOM结构，这提供了很多可能，但两者间也存在这种差异。

虚拟DOM的另一个好处是，它把渲染逻辑从真实DOM中解耦出来，我们先计算差异，然后将这些更改应用到DOM上，如果我们放弃最后一步，我们应用所有的更新逻辑实际上都是被执行，它不需要接触DOM，实际上，如果我们抽象出这些最终连接点操作DOM的API，然后把它们应用到别的地方，我们就可应用任何支持虚拟环境的JavaScript应用，但不一定是DOM，相反它可以是原生渲染引擎例如iOS或Android或者在服务器端，我们可以将虚拟DOM转换为字符串或字符串查找器，让虚拟DON进行原生渲染像Weeks，Native script这样的项目成为可能，它们的架构都是类似的。JavaScript应用实际上是嵌入到JavaScript引擎中运行。它只发送必要的消息，例如差异更改或任何实际的节点操作发送到渲染器。因此，这就是虚拟DOM的架构优势。显然虚拟DOM不是实现这一目标的唯一方法，但这是一个很好的方法。最后渲染函数只是返回虚拟DOM的函数，template在Vuejs是通过渲染函数编译的 。

把渲染函数和响应式整合起来，每个组件都有一个渲染函数。而这个渲染函数，它实际上包装在我们之前实现的autoRun函数。当渲染的时候，我们收集它们的依赖通过调用我们data属性的getters。我们有了这个额外的概念--观察者。每个组件都有一个负责监视的观察者收集依赖项，清理它们并通知所有内容。组件渲染函数返回虚拟DOM。你会看到这里是循环的，因为我们的渲染放在autoRun中，渲染将会反复调用，只要我们依赖的渲染属性发生变化。每个组件都有自己自动循环渲染。组件树由许多组件组成，每个组件都只负责自己的依赖。因此当你拥有巨大的组件树时，这实际上是一个优势，因为你可以更改数据依赖关系，你的数据可以在任何地方发生改变，因为每个组件都只负责自己的依赖在这个组件树中。我们确切地知道哪些组件受到哪些数据的影响。所以，它不会过度渲染，不会造成过多的组件重新渲染。因为我们有一个精确的依赖跟踪系统。因此这是一种架构优势，可摆脱一些优化工作。React使用的是基于自上而下的渲染模型，但是我们还付出了将这些数据转换为getter和setter的开销，这确实也有一点开销。因此这不是万灵药，双方都有利弊，但这两种方法都是可行的，React和V ue用这两种方法构建大规模应用都没什么问题，实际上差异指挥在非常极端的情况下才会出现